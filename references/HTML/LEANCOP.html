<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>LEANCOP : thm list -&gt; term -&gt; thm</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Attempt to prove a term by first-order proof search using leanCop
connection-based prover.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
A call <SPAN CLASS=BRKT>LEANCOP[theorems] `tm`</SPAN> will attempt to prove <SPAN CLASS=BRKT>tm</SPAN> using pure
first-order reasoning, taking <SPAN CLASS=BRKT>theorems</SPAN> as the starting-point. It will usually
either prove it completely or run for an infeasibly long time, but it may
sometimes fail quickly.

Although <SPAN CLASS=BRKT>LEANCOP</SPAN> is capable of some fairly non-obvious pieces of first-order
reasoning, and will handle equality adequately, it does purely logical
reasoning. It will exploit no special properties of the constants in the goal,
other than equality and logical primitives. Any properties that are needed must
be supplied explicitly in the theorem list, e.g. <SPAN CLASS=BRKT>LE_REFL</SPAN> to tell it that <SPAN CLASS=BRKT><=</SPAN>
on natural numbers is reflexive, or <SPAN CLASS=BRKT>REAL_ADD_SYM</SPAN> to tell it that addition on
real numbers is symmetric.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if the term is unprovable within the search bounds.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
A typical application is to prove some elementary logical lemma for use inside
a tactic proof:
<DIV class=XMPL><PRE>
  # LEANCOP [EXTENSION; IN_INSERT]
      `x INSERT y INSERT s = y INSERT x INSERT s`;;
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
Generating simple logical lemmas as part of a large proof.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="LEANCOP_TAC.html">LEANCOP_TAC</A>, <A href="MESON.html">MESON</A>, <A href="METIS.html">METIS</A>, <A href="NANOCOP.html">NANOCOP</A>.


</DL>
